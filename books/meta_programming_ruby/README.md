# メタプログラミングRuby

## 1. 頭文字 M
rubyは言語要素のほとんどが実行時に存在しており、使用可能(イントロスペクション)
c++は、コンパイルすると、変数やメソッドは実態を失い、メモリに配置されている。そのため、rubyのように言語要素を使用できない。
`メタプログラミングとは、言語要素を実行時に操作するコードを記述すること`

## 2
### 2.1
rubyのclassは、クラス宣言というよりもスコープ演算子のようなもの。
そのため、既存のクラスを再オープンして、新たにメソッドを追加することができる。(オープンクラス)
安易にオープンクラスを用いて、メソッドを追加すると、すでにあるメソッドを上書く可能性があるので、注意

### 2.2
インスタンス変数は値が代入されて、はじめて出現する。
そのため、同じクラスのオブジェクトでもインスタンス変数が共有されない

オブジェクトには、インスタン変数とクラスへの参照があるだけで、メソッドは持っていない
オブジェクトが持っているクラスの参照は変えられる?

クラスはClassクラスのインスタンスである。つまり、クラスもオブジェクトである。

クラスはオブジェクトであり、クラス名は定数である
定数と変数はスコープのルールが違い、定数はファイルシステムのようにツリー状に配置されている

### 2.4
どこからでも呼び出せるメソッドがあるが、実際はKernelモジュールのprivateインスタンスメソッドであり、
rubyのコードは常にオブジェクトの内部で実行されるため、Kernelモジュールのメソッドが呼び出すことができる(ObjectクラスはKernelをインクルードしている)
例: Awesome Printというgem

メソッドを呼び出すときは、メソッドのレシーバーがselfになる

## 3
重複コードを排除するには、`動的メソッド`, `method_missing`の2つの方法がある
メソッドを呼び出す = オブジェクトにメッセージを送る

### 動的メソッド
#### 動的に呼び出す
Object#sendを使ってメソッドを呼び出すことができる
Object#sendを使うことで、コードの実行時に呼び出すメソッドを決めることができる(`動的ディスパッチ`)
例: Pry gem

#### 動的に定義する
Module#define_methodを使うことで、動的にメソッドを定義することができる

### method_missing
例: Hashie gem, Ghee gem
respond_to? はゴーストメソッドに対してfalseを返す
respond_to?はrespond_to_missing?を呼び出している
method_missingをオーバーライドしたときに、respond_to_missing?をオーバーライドすれば良い
method_missingをオーバーライドするときは、忘れずにrespond_to_missing?もオーバーライドする
(Module#const_missingは定数が存在しないとき呼ばれる)

いきなりmethod_missingを使わないで、通常のメソッドを書き、必要であればmethod_missingを使いリファクタリングをする
method_missingで処理したいメソッドが、実際に継承しているクラスに存在している場合がある -> undefでメソッドを削除することができる or BasicObjectからクラスを作成する

## 4
ブロックはスコープを制御する強力なツール

ブロックのコードを実行するには、`ローカル変数`, `インスタンス変数`, `self`が必要(束縛)
つまり、ブロックには`コードと束縛の集まりの両方`が含まれる
